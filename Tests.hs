-- Copyright (c) 2011 Kevin Cantu <me@kevincantu.org>
--
-- A naive implementation of the Blake cryptographic hash: 
-- use at your own risk.

import Test.HUnit
import SHA3.BLAKE
import qualified Data.ByteString.Lazy as B


zeroByteString :: Int -> B.ByteString
zeroByteString n = B.pack $ take n $ repeat 0

test_blake256 :: Test 
test_blake256 = 
    TestCase $ do
        assertEqual "BLAKE-256 of '0x00'" 
            (B.pack [0x0C,0xE8,0xD4,0xEF, 0x4D,0xD7,0xCD,0x8D, 0x62,0xDF,0xDE,0xD9, 0xD4,0xED,0xB0,0xA7, 
                     0x74,0xAE,0x6A,0x41, 0x92,0x9A,0x74,0xDA, 0x23,0x10,0x9E,0x8F, 0x11,0x13,0x9C,0x87])
            (blake256 (zeroByteString 16) (zeroByteString 1))

        assertEqual "BLAKE-256 of 72 by '0x00'" 
            (B.pack [0xD4,0x19,0xBA,0xD3, 0x2D,0x50,0x4F,0xB7, 0xD4,0x4D,0x46,0x0C, 0x42,0xC5,0x59,0x3F, 
                     0xE5,0x44,0xFA,0x4C, 0x13,0x5D,0xEC,0x31, 0xE2,0x1B,0xD9,0xAB, 0xDC,0xC2,0x2D,0x41])
            (blake256 (zeroByteString 16) (zeroByteString 72))


test_blake512 :: Test 
test_blake512 = 
    TestCase $ do
        assertEqual "BLAKE-512 of '0x00'"
            (B.pack [0x97,0x96,0x15,0x87,0xF6,0xD9,0x70,0xFA, 0xBA,0x6D,0x24,0x78,0x04,0x5D,0xE6,0xD1,
                     0xFA,0xBD,0x09,0xB6,0x1A,0xE5,0x09,0x32, 0x05,0x4D,0x52,0xBC,0x29,0xD3,0x1B,0xE4,
                     0xFF,0x91,0x02,0xB9,0xF6,0x9E,0x2B,0xBD, 0xB8,0x3B,0xE1,0x3D,0x4B,0x9C,0x06,0x09,
                     0x1E,0x5F,0xA0,0xB4,0x8B,0xD0,0x81,0xB6, 0x34,0x05,0x8B,0xE0,0xEC,0x49,0xBE,0xB3])
            (blake512 (zeroByteString 32) $ B.pack [0]) 
            
        assertEqual "BLAKE-512 of 144 by '0x00'"
            (B.pack [0x31,0x37,0x17,0xD6,0x08,0xE9,0xCF,0x75, 0x8D,0xCB,0x1E,0xB0,0xF0,0xC3,0xCF,0x9F,
                     0xC1,0x50,0xB2,0xD5,0x00,0xFB,0x33,0xF5, 0x1C,0x52,0xAF,0xC9,0x9D,0x35,0x8A,0x2F,
                     0x13,0x74,0xB8,0xA3,0x8B,0xBA,0x79,0x74, 0xE7,0xF6,0xEF,0x79,0xCA,0xB1,0x6F,0x22,
                     0xCE,0x1E,0x64,0x9D,0x6E,0x01,0xAD,0x95, 0x89,0xC2,0x13,0x04,0x5D,0x54,0x5D,0xDE])
            (blake512 (zeroByteString 32) (zeroByteString 144)) 


test_blake384 :: Test 
test_blake384 = 
    TestCase $ do
        assertEqual "BLAKE-384 of '0x00'"
            (B.pack [0x10,0x28,0x1F,0x67,0xE1,0x35,0xE9,0x0A, 0xE8,0xE8,0x82,0x25,0x1A,0x35,0x55,0x10,
                     0xA7,0x19,0x36,0x7A,0xD7,0x02,0x27,0xB1, 0x37,0x34,0x3E,0x1B,0xC1,0x22,0x01,0x5C,
                     0x29,0x39,0x1E,0x85,0x45,0xB5,0x27,0x2D, 0x13,0xA7,0xC2,0x87,0x9D,0xA3,0xD8,0x07])
            (blake384 (zeroByteString 32) $ B.pack [0]) 

        assertEqual "BLAKE-384 of 144 by '0x00'"
            (B.pack [0x0B,0x98,0x45,0xDD,0x42,0x95,0x66,0xCD, 0xAB,0x77,0x2B,0xA1,0x95,0xD2,0x71,0xEF, 
                     0xFE,0x2D,0x02,0x11,0xF1,0x69,0x91,0xD7, 0x66,0xBA,0x74,0x94,0x47,0xC5,0xCD,0xE5, 
                     0x69,0x78,0x0B,0x2D,0xAA,0x66,0xC4,0xB2, 0x24,0xA2,0xEC,0x2E,0x5D,0x09,0x17,0x4C])
            (blake384 (zeroByteString 32) (zeroByteString 144))


test_blake224 :: Test 
test_blake224 = 
    TestCase $ do
        assertEqual "BLAKE-224 of '0x00'"
            (B.pack [0x45,0x04,0xCB,0x03, 0x14,0xFB,0x2A,0x4F, 
                     0x7A,0x69,0x2E,0x69, 0x6E,0x48,0x79,0x12, 
                     0xFE,0x3F,0x24,0x68, 0xFE,0x31,0x2C,0x73, 0xA5,0x27,0x8E,0xC5])
            (blake224 (zeroByteString 16) (B.pack [0])) 

        assertEqual "BLAKE-224 of 72 by '0x00'" 
            (B.pack [0xF5,0xAA,0x00,0xDD, 0x1C,0xB8,0x47,0xE3, 
                     0x14,0x03,0x72,0xAF, 0x7B,0x5C,0x46,0xB4, 
                     0x88,0x8D,0x82,0xC8, 0xC0,0xA9,0x17,0x91, 0x3C,0xFB,0x5D,0x04])
            (blake224 (zeroByteString 16) (zeroByteString 72))


tests :: Test
tests = TestList [ "BLAKE-256"            ~: test_blake256
                 , "BLAKE-512"            ~: test_blake512
                 , "BLAKE-224"            ~: test_blake224
                 , "BLAKE-384"            ~: test_blake384
                 ]


main :: IO ()
main = runTestTT tests >>= putStrLn . show  -- TODO: what output does cabal need?


